<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>

@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}

.type0 {
  fill: red;
}

.type1 {
  fill: blue;
}

.type2 {
  fill: green;
}

.type3 {
  fill: yellow;
}

.link.type0c {
  stroke: red;
}

.link.type1c {
  stroke: blue;
}

.link.type2c {
  stroke: green;
}

.link.type3c {
  stroke: yellow;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Kidney Exchange</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here
      <p>
      </p>
    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>

    </div>
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
      from gurobipy import *

      vertices  = range(5)
      edges = { (0,1) : 1, (1,0) : 1, (0,2) : 1, (2,0) : 1,
                (0,4) : 1, (4,0) : 1, (1,4) : 1, (4,1) : 1,
                (1,3) : 1, (3,1) : 1, (2,3) : 1, (3,2) : 1,
                (3,4) : 1, (4,3) : 1 }

      def twoCycle(vertices, edges):
          '''
          Returns a dictionary of 2 cycles. Keys: (u,v), Value: weight of cycle
          Note that u < v to not double count cycles.
          '''
          twoCycles = {}
          for edge in edges:
              u = edge[0]
              v = edge[1]
              if (u < v and (v,u) in edges):
                  twoCycles[(u,v)] = edges[(u,v)] + edges[(v,u)]
          return twoCycles

      def threeCycle(vertices, edges):
          '''
          Returns a dictionary of 3 cycles. Keys: (u,w,v), Value: weight of cycle
          Note that w is always the lowest numbered vertex to not double
          (or triple) count cycles.
          '''
          threeCycles = {}
          for edge in edges:
              u = edge[0]
              v = edge[1]
              for w in vertices:
                  if (w >= u or w >= v ):
                      break
                  if ( (u,w) in edges and (w,v) in edges ):
                      threeCycles[(u,w,v)] = edges[(u,v)] + edges[(u,w)] + edges[(w,v)]
          return threeCycles

      twoCycles = twoCycle(vertices,edges)
      threeCycles = threeCycle(vertices,edges)

      m = Model()

      c = {}

      for cycle in twoCycles:
          c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

      for cycle in threeCycles:
          c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

      m.update()

      for v in vertices:
          constraint = 0
          for cycle in c:
              if (v in cycle):
                  constraint = constraint + c[cycle]
          m.addConstr( constraint <= 1 , name="v%d" % v)

      m.setObjective( quicksum( c[cycle] * twoCycles[cycle] for cycle in twoCycles ) +
                      quicksum( c[cycle] * threeCycles[cycle] for cycle in threeCycles ),
                      GRB.MAXIMIZE )

      m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>


      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute</button>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

//Width, height and button width
var width = 800;
var height = 650;
var bw = width/10;
var menu = 80;
var delta = 10;
var radius = 250;
var numCircles = 10;
var circleSize = 27;

// Compatibility matrix between different donors and acceptors
var type12 = .5, type13 = .2, type14 = 0;
var type23 = 0, type24 = .7;
var type34 = .6;
var compatibility = [[1, type12, type13, type14],
                     [type12, 1, type23, type24],
                     [type13, type23, 1, type34],
                     [type14, type24, type34, 1]];

// Initial types
var typea = "type0";
var typeb = "type1";

// Graphics
var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

var backgroundG = svg.append("g");
backgroundG.append("rect")
           .attr("x", 0)
           .attr("y", menu)
           .attr("width", width)
           .attr("height", height - menu)
           .attr("fill", "black")
           .attr("opacity", .1);

// Create buttons on a circle
var positions = [];
for (var i = 0; i < numCircles; i++) {
  var angle = 2*Math.PI*i/(numCircles);
  positions.push([ width/2 + radius * Math.cos(angle),  (height+menu)/2 + radius * Math.sin(angle)]);
}

backgroundG.selectAll("circle")
           .data(positions)
           .enter()
           .append("circle")
           .attr("cx", function(d) { return d[0]; })
           .attr("cy", function(d) { return d[1]; })
           .attr("r", circleSize)
           .attr("stroke", "black")
           .attr("stroke-width", 3)
           .attr("stroke-opacity", 1)
           .attr("fill", "black")
           .attr("opacity", .5)
           .on("mousedown", addPoint);

// Initial points
var vertices = [];
var verticesType = [];

var buttondata1 = [bw, 2*bw, 3*bw, 4*bw];
var buttondata2 = [6*bw, 7*bw, 8*bw, 9*bw];

// G object for points
var pointsG = svg.append("g");

// G object for solution
var solutionG = svg.append("g");

// G objects for buttons
var buttonsG1 = svg.append("g");
var buttonsG2 = svg.append("g");

// Create graphics related to buttons
buttonsG1.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", menu)
        .attr("fill", "black")
        .attr("opacity", .5)
        .attr("stroke", "black");

buttonsG1.append("text")
        .attr("x", width/4)
        .attr("y", 25)
        .text("DONOR");

buttonsG1.append("text")
        .attr("x", 3*width/4)
        .attr("y", 25)
        .text("ACCEPTOR");

buttonsG1.selectAll("text")
       .attr("font-size", "25px")
       .attr("fill", "white")
       .attr("text-anchor", "middle");

var buttons1 = buttonsG1.selectAll("circle")
                      .data(buttondata1)
                      .enter()
                      .append("circle")
                      .attr("cx", function(d) { return d; })
                      .attr("cy", 55)
                      .attr("r", 15)
                      .attr("class", function(d,i) { return "type" + i % 4 ; })
                      .attr("opacity", .3)
                      .attr("stroke", "black")
                      .on("mousedown", buttonpress1);

var buttons2 = buttonsG2.selectAll("circle")
                      .data(buttondata2)
                      .enter()
                      .append("circle")
                      .attr("cx", function(d) { return d; })
                      .attr("cy", 55)
                      .attr("r", 15)
                      .attr("class", function(d,i) { return "type" + i % 4 ; })
                      .attr("opacity", .3)
                      .attr("stroke", "black")
                      .on("mousedown", buttonpress2);

// Add markers to create arrows
svg.append("defs").selectAll("marker")
    .data(["type0", "type1", "type2", "type3"])
    .enter().append("marker")
    .attr("id", function(d) { return d; })
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 0)
    .attr("refY", 0)
    .attr("markerWidth", 8)
    .attr("markerHeight", 8)
    .attr("orient", "auto")
    .attr("class", function(d) { return d; })
    .append("path")
    .attr("d", "M0,-5L10,0L0,5");

// Different color gradients for the half circles
var grad00 = svg.append("defs").append("linearGradient").attr("id", "grad00")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad00.append("stop").attr("offset", "50%").style("stop-color", "red");
grad00.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad01 = svg.append("defs").append("linearGradient").attr("id", "grad01")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad01.append("stop").attr("offset", "50%").style("stop-color", "red");
grad01.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad02 = svg.append("defs").append("linearGradient").attr("id", "grad02")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad02.append("stop").attr("offset", "50%").style("stop-color", "red");
grad02.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad03 = svg.append("defs").append("linearGradient").attr("id", "grad03")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad03.append("stop").attr("offset", "50%").style("stop-color", "red");
grad03.append("stop").attr("offset", "50%").style("stop-color", "yellow");
var grad10 = svg.append("defs").append("linearGradient").attr("id", "grad10")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad10.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad10.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad11 = svg.append("defs").append("linearGradient").attr("id", "grad11")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad11.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad11.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad12 = svg.append("defs").append("linearGradient").attr("id", "grad12")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad12.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad12.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad13 = svg.append("defs").append("linearGradient").attr("id", "grad13")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad13.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad13.append("stop").attr("offset", "50%").style("stop-color", "yellow");
var grad20 = svg.append("defs").append("linearGradient").attr("id", "grad20")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad20.append("stop").attr("offset", "50%").style("stop-color", "green");
grad20.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad21 = svg.append("defs").append("linearGradient").attr("id", "grad21")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad21.append("stop").attr("offset", "50%").style("stop-color", "green");
grad21.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad22 = svg.append("defs").append("linearGradient").attr("id", "grad22")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad22.append("stop").attr("offset", "50%").style("stop-color", "green");
grad22.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad23 = svg.append("defs").append("linearGradient").attr("id", "grad23")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad23.append("stop").attr("offset", "50%").style("stop-color", "green");
grad23.append("stop").attr("offset", "50%").style("stop-color", "yellow");
var grad30 = svg.append("defs").append("linearGradient").attr("id", "grad30")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad30.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad30.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad31 = svg.append("defs").append("linearGradient").attr("id", "grad31")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad31.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad31.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad32 = svg.append("defs").append("linearGradient").attr("id", "grad32")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad32.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad32.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad33 = svg.append("defs").append("linearGradient").attr("id", "grad33")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad33.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad33.append("stop").attr("offset", "50%").style("stop-color", "yellow");

/* Note you should probably use Arcs for the half circles instead
  var vis = d3.select("body").append("svg")
var pi = Math.PI;

var arc = d3.svg.arc()
    .innerRadius(50)
    .outerRadius(70)
    .startAngle(45 * (pi/180)) //converting from degs to radians
    .endAngle(3) //just radians

vis.append("path")
    .attr("d", arc)
    .attr("transform", "translate(50,50)")
 */

function buttonpress1() {
  typea = d3.select(this).attr("class");
  buttons1.attr("stroke-width", 1)
          .attr("opacity", .3);
  d3.select(this).attr("stroke-width", 3)
                 .attr("opacity", .9);
  console.log([typea, typeb]);
}

function buttonpress2() {
  typeb = d3.select(this).attr("class");
  buttons2.attr("stroke-width", 1)
          .attr("opacity", .3);
  d3.select(this).attr("stroke-width", 3)
                 .attr("opacity", .9);
  console.log([typea, typeb]);
}

function indexArray (array, point) {
  var p0 = point[0];
  var p1 = point[1];
  var bool = false;
  var index = -1;
  for (i = 0; i < array.length; i++) {
    pointprime = array[i];
    if (p0 === pointprime[0] && p1 === pointprime[1]) {
      bool = true;
      index = i;
      break;
    }
  }
  return [bool,index];
}

function addPoint() {
  var point = [0,0];
  point[0] = d3.select(this).attr("cx");
  point[1] = d3.select(this).attr("cy");

  if (typea === "type0" && typeb === "type0") { d3.select(this).attr("fill", "url(#grad00)"); }
  if (typea === "type0" && typeb === "type1") { d3.select(this).attr("fill", "url(#grad01)"); }
  if (typea === "type0" && typeb === "type2") { d3.select(this).attr("fill", "url(#grad02)"); }
  if (typea === "type0" && typeb === "type3") { d3.select(this).attr("fill", "url(#grad03)"); }
  if (typea === "type1" && typeb === "type0") { d3.select(this).attr("fill", "url(#grad10)"); }
  if (typea === "type1" && typeb === "type1") { d3.select(this).attr("fill", "url(#grad11)"); }
  if (typea === "type1" && typeb === "type2") { d3.select(this).attr("fill", "url(#grad12)"); }
  if (typea === "type1" && typeb === "type3") { d3.select(this).attr("fill", "url(#grad13)"); }
  if (typea === "type2" && typeb === "type0") { d3.select(this).attr("fill", "url(#grad20)"); }
  if (typea === "type2" && typeb === "type1") { d3.select(this).attr("fill", "url(#grad21)"); }
  if (typea === "type2" && typeb === "type2") { d3.select(this).attr("fill", "url(#grad22)"); }
  if (typea === "type2" && typeb === "type3") { d3.select(this).attr("fill", "url(#grad23)"); }
  if (typea === "type3" && typeb === "type0") { d3.select(this).attr("fill", "url(#grad30)"); }
  if (typea === "type3" && typeb === "type1") { d3.select(this).attr("fill", "url(#grad31)"); }
  if (typea === "type3" && typeb === "type2") { d3.select(this).attr("fill", "url(#grad32)"); }
  if (typea === "type3" && typeb === "type3") { d3.select(this).attr("fill", "url(#grad33)"); }
  // Here what we want is that when circle is clicked:
  // Remove the thing that is currently there and add the new circles
  // Have an array where you keep track of where shiz is. Maybe we can give
  // a class to each circle you can click? Then you can check if thing is a class
  // and then add or remove it from vertices and verticesTypes
  // Want an array like [0,0,1,0,1,1,0,0,1] for selected circles
  console.log(point)
  var check = indexArray(vertices, point);
  if (check[0]) {
    console.log('point already exists!');
    verticesType[check[1]] = [typea,typeb];
    return;
  } else {
    vertices.push(point);
    verticesType.push([typea, typeb]);
  }

  console.log('verticesType', verticesType);
  console.log('vertices', vertices)
}

function linkArc(d) {
  var source = vertices[d.source];
  var target = vertices[d.target];
  var dx = target[0] - source[0],
      dy = target[1] - source[1],
      dr = Math.sqrt(dx * dx + dy * dy);
  return "M" + source[0] + "," + source[1] + "A" + dr + "," + dr + " 0 0,1 " + target[0] + "," + target[1];
}

function compute() {
  var nodes = [];
  var edges = { 1 : [], 0.5 : [], 0.2 : [],
                0.7 : [], 0.6 : []};

  var nonzeros = 0;

  for (var i = 0; i < verticesType.length; i++) { // Iterate over donors
    nodes.push(i);
    for (var j = 0; j < verticesType.length; j++) { // Iterate over acceptors
      if (i !== j) {
        var node1 = verticesType[i][0].charAt(4);
        var node2 = verticesType[j][1].charAt(4);
        node1 = parseInt(node1);
        node2 = parseInt(node2);
        var edgeweight = compatibility[node1][node2];
        console.log('edgeweight', edgeweight);
        if (edgeweight !== 0) {
          edges[edgeweight].push([i,j]);
          nonzeros = 1;
        }
      }
    }
  }
  console.log('nodes', nodes);
  console.log('edges', edges);

  if (nonzeros === 0) {
    console.log("No compatible acceptor donor pairs!");
    return;
  }

  d3.json('/kidneyExchange')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'nodes': nodes,
                          'edges': edges}), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('solution' in data) {
          var solution = data['solution'];
          console.log('solution', solution)
          links = []
          for (var i = 0; i < solution.length; i++) {
            cycle = solution[i];
            console.log(cycle);
            for (var j = 0; j < cycle.length - 1; j++) {
              links.push({source: cycle[j], target: cycle[j+1],
                         type: verticesType[cycle[j]][0]});
              console.log(verticesType[cycle[j]]);
            }
            links.push({source: cycle[cycle.length-1], target: cycle[0],
                       type: verticesType[cycle[cycle.length-1]][0]});
            console.log(verticesType[cycle[cycle.length-1]]);
          }
          console.log('links', links);
          console.log('verticesType', verticesType)
          solutionG.selectAll("path").remove("path");

          // Draw the cycles
          var cycles = solutionG.selectAll("path")
                    .data(links)
                    .enter()
                    .append("path")
                    .attr("class", function(d) { return "link " + d.type + "c";})
                    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; })
                    .attr("d", function(d) { return linkArc(d); })
                    .attr("fill", "none")
                    .attr("stroke-opacity", .7)
                    .attr("stroke-width", 3);
      }
   }
}
</script>
