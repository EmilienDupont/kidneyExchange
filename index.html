<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="http://examples.gurobi.com/base.css">
<style>

.type0 {
}

.type1 {
}

.type2 {
}

.type3 {
}

.node {
  stroke-width: 3;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="example_container">
    <div class="example_section" id="intro">
      <h1>Kidney Exchange</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <p> Imagine a person in need of a kidney transplant who has a willing donor (e.g.
    a family member). The donor's kidney is, however, incompatible with the patient
    (because of differing blood types for example) and so the transplant cannot be made.
    Now, suppose there are two patient-donor pairs. Donor 1 and patient 1 have incompatible
    kidneys, but donor 2's kidney is compatible with patient 1 and donor 1's kidney is
    compatible with patient 2's. A kidney exchange can then take place: patient 1 receives
    kidney 2, and patient 2 receives kidney 1.</p>

    <p> Now imagine this problem on a national scale. There are currently 70,000 patients
    waiting on kidneys in the US. Using kidney exchange, the number of deaths related to
    kidney disease could be significantly reduced. </p>

    <p>
      In this example we'll solve the kidney exchange problem. We'll construct a mathematical
      model of the problem, implement this model in Gurobi's Python interface, and compute
      and visualize an optimal solution.
    </p>
    <p> Reference the http://www.cs.cmu.edu/~sandholm/kidneyExchange.EC07.withGrantInfo.pdf paper</p>

    <div class="example_section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here
      <p> Mention why cycles need to be short</p>
      <p>
        Kidney exchange is an example of the more general Barter Exchange Market problem.
        In this problem, agents seek to swap their items, creating cycles of agents where
        each agent receives the item from the previous agent in the cycle. The goal is then
        to find the cycles which maximize the utilities of each agent.
      </p>
    </div>
    <div class="example_section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>

      <p> Let $G$ be a graph where the set of vertices $V$ corresponds to acceptor/donor pairs
      and the set of directed weighted edges $E$ represent a compatibility factor between a donor and an acceptor. </p>

      <p> Let $C$ be the set of cycles in the graph of length at most 3. Let $w_c$ denote the weight of
      the cycle, which is the sum of the edge weights in the cycle. Our goal is to find a cycle cover
      of the graph with maximum weight. Therefore we define a binary variable $c$ for each cycle
      such that
      \[
      c = \left\{\begin{array}{ll}
             1 & \text{if cycle is in the cover}\\
             0 & \mathrm{otherwise}
            \end{array}\right.
      \]
      </p>
      <p> The objective we seek to maximize is the total weight of the cover, i.e.
      \[
      \text{cycle cover weight} = \sum_{c \in C} w_c c
      \]</p>
      <p> Now since an acceptor only needs to receive one kidney and a donor can at most give one kidney,
    each vertex of the vertex the graph can be in at most one cycle. We therefore find all the cycles in which
    a given vertex $v$ is included. To impose the constraint, the sum of these binary variables can at most be one.
    So we have the set of constraints (one for each vertex $v$)
    \[
    \sum_{c : v \in c} c \leq 1 \quad \forall v \in V
    \]
      </p>
      <p> So finally we have
       \[
      \begin{array}{ll}
      \text{maximize} & \sum_{c \in C} w_c c \\
      \text{subject to} & \sum_{c : v \in c} c \leq 1 \quad \forall v \in V \\
                        & c \in \{ 0, 1 \} \quad \forall c \in C
      \end{array}
      \]
      </p>
    </div>
    <div class="example_section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <examplecode>
      from gurobipy import *

      vertices  = range(5)
      edges = { (0,1) : 1, (1,0) : 1, (0,2) : 1, (2,0) : 1,
                (0,4) : 1, (4,0) : 1, (1,4) : 1, (4,1) : 1,
                (1,3) : 1, (3,1) : 1, (2,3) : 1, (3,2) : 1,
                (3,4) : 1, (4,3) : 1 }

      def twoCycle(vertices, edges):
          '''
          Returns a dictionary of 2 cycles. Keys: (u,v), Value: weight of cycle
          Note that u < v to not double count cycles.
          '''
          twoCycles = {}
          for edge in edges:
              u = edge[0]
              v = edge[1]
              if (u < v and (v,u) in edges):
                  twoCycles[(u,v)] = edges[(u,v)] + edges[(v,u)]
          return twoCycles

      def threeCycle(vertices, edges):
          '''
          Returns a dictionary of 3 cycles. Keys: (u,w,v), Value: weight of cycle
          Note that w is always the lowest numbered vertex to not double
          (or triple) count cycles.
          '''
          threeCycles = {}
          for edge in edges:
              u = edge[0]
              v = edge[1]
              for w in vertices:
                  if (w >= u or w >= v ):
                      break
                  if ( (u,w) in edges and (w,v) in edges ):
                      threeCycles[(u,w,v)] = edges[(u,v)] + edges[(u,w)] + edges[(w,v)]
          return threeCycles

      twoCycles = twoCycle(vertices,edges)
      threeCycles = threeCycle(vertices,edges)

      m = Model()

      c = {}

      for cycle in twoCycles:
          c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

      for cycle in threeCycles:
          c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

      m.update()

      for v in vertices:
        constraint = []
        for cycle in c:
            if (v in cycle):
                constraint.append(c[cycle])
        if constraint:
            m.addConstr( quicksum( constraint[i] for i in range(len(constraint)) ) <= 1 , name="v%d" % v)

      m.setObjective( quicksum( c[cycle] * twoCycles[cycle] for cycle in twoCycles ) +
                      quicksum( c[cycle] * threeCycles[cycle] for cycle in threeCycles ),
                      GRB.MAXIMIZE )

      m.optimize()
      </examplecode>
    </div>
    <div class="example_section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p> Click on the buttons at the top to change the type of acceptor/donor pairs. Click
      on the circles to add/change pairs. Click compute to compute the optimal kidney exchange. </p>
      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute</button>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

/*******************************
 *
 *        LAYOUT DATA
 *
 *******************************/

//Width, height button width, menu size
var width = 800;
var height = 650;
var bw = width/10;
var menu = 80;
var colors = ["#a6cee3","#1f78b4","#b2df8a","#33a02c"];

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);


/*******************************
 *
 *     CREATE FORCE LAYOUT
 *
 *******************************/

// Initial graph
graph = {
  "nodes":[
    {"donor":"type2","acceptor":"type0"},
    {"donor":"type1","acceptor":"type3"},
    {"donor":"type2","acceptor":"type1"},
    {"donor":"type0","acceptor":"type3"},
    {"donor":"type3","acceptor":"type1"},
    {"donor":"type1","acceptor":"type0"}
  ],
  "links":[
    {"source":0,"target":0,"value":1}
  ]
}

// Set up force layout
var force = d3.layout.force()
    .nodes(graph.nodes)
    .links(graph.links)
    .charge(-400)
    .linkDistance(120)
    .size([width, height + menu/2])
    .on("tick", tick);

var link = svg.selectAll(".link");

var node = svg.selectAll(".node");

function start() {
  console.log("in start()");

  force.nodes(graph.nodes)
       .links(graph.links)
       .start();

  link.remove();
  link = link.data(graph.links)
          .enter().append("path")
          .attr("d", function(d) {
            console.log('d', d);
              var dx = d.target.x - d.source.x,
                  dy = d.target.y - d.source.y,
                  dr = Math.sqrt(dx * dx + dy * dy);
              return "M" +
                  d.source.x + "," +
                  d.source.y + "A" +
                  dr + "," + dr + " 0 0,1 " +
                  d.target.x + "," +
                  d.target.y;
          })
          .attr("class", "link")
          .style("stroke-width", function(d) { return Math.sqrt(d.value); })
          .attr("fill", "none");

  node.remove();
  node = node.data(graph.nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", 8)
        .style("fill", function(d) { return colorfill(d.donor); })
        .style("stroke", function(d) { return colorfill(d.acceptor)})
        .call(force.drag);

  force.start();
}

function tick() {
  link.attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" +
            d.source.x + "," +
            d.source.y + "A" +
            dr + "," + dr + " 0 0,1 " +
            d.target.x + "," +
            d.target.y;
    })

  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

// Function to color the nodes
function colorfill(colortype) {
  return colors[parseInt(colortype[4])]; // E.g. if "type0" return colors[0]
}

start();

/*******************************
 *
 *      CREATING G OBJECTS
 *
 *******************************/
// G object for points
var pointsG = svg.append("g");

// G object for solution
var solutionG = svg.append("g");

// G objects for buttons
var buttonsG1 = svg.append("g");
var buttonsG2 = svg.append("g");
var buttonsG3 = svg.append("g");




/*******************************
 *
 *      CREATING BUTTONS
 *
 *******************************/

var buttondata1 = [bw, 2*bw, 3*bw, 4*bw];
var buttondata2 = [6*bw, 7*bw, 8*bw, 9*bw];

// Create graphics related to buttons
buttonsG1.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", menu)
        .attr("fill", "black")
        .attr("opacity", .5)
        .attr("stroke", "black");

buttonsG1.append("text")
        .attr("x", width/4)
        .attr("y", 25)
        .text("DONOR");

buttonsG1.append("text")
        .attr("x", 3*width/4)
        .attr("y", 25)
        .text("ACCEPTOR");

buttonsG1.selectAll("text")
       .attr("font-size", "25px")
       .attr("fill", "white")
       .attr("text-anchor", "middle");

var buttons1 = buttonsG1.selectAll("circle")
          .data(buttondata1)
          .enter()
          .append("circle")
          .attr("cx", function(d) { return d; })
          .attr("cy", 55)
          .attr("r", 15)
          .attr("class", function(d,i) { return "type" + i % 4 ; })
          .attr("fill", function(d,i) { return colors[i % 4];})
          .attr("stroke-width", function(d,i) { if (i === 0) { return 3; } else { return 1; } })
          .attr("opacity", function(d,i) { if (i === 0) { return 0.9; } else { return .3; } })
          .attr("stroke", "black")
          .on("mousedown", buttonpress1);

var buttons2 = buttonsG2.selectAll("circle")
          .data(buttondata2)
          .enter()
          .append("circle")
          .attr("cx", function(d) { return d; })
          .attr("cy", 55)
          .attr("r", 15)
          .attr("class", function(d,i) { return "type" + i % 4 ; })
          .attr("fill", function(d,i) { return colors[i % 4];})
          .attr("stroke-width", function(d,i) { if (i === 1) { return 3; } else { return 1; } })
          .attr("opacity", function(d,i) { if (i === 1) { return 0.9; } else { return .3; } })
          .attr("stroke", "black")
          .on("mousedown", buttonpress2);

buttonsG3.append("rect")
         .attr("x", width/2 - 50)
         .attr("y", 25)
         .attr("height", 50)
         .attr("width", 100)
         .attr("stroke-width", 3)
         .attr("stroke", "black")
         .attr("fill", "rgb(210,210,210)")
         .on("mousedown", addPoint);

buttonsG3.append("text")
        .text("ADD")
        .attr("x", width/2)
        .attr("y", 60)
        .attr("font-size", "25px")
        .attr("fill", "white")
        .attr("text-anchor", "middle");

function buttonpress1() {
  typeD = d3.select(this).attr("class");
  buttons1.attr("stroke-width", 1)
          .attr("opacity", .3);
  d3.select(this).attr("stroke-width", 3)
                 .attr("opacity", .9);
  console.log([typeD, typeA]);
}

function buttonpress2() {
  typeA = d3.select(this).attr("class");
  buttons2.attr("stroke-width", 1)
          .attr("opacity", .3);
  d3.select(this).attr("stroke-width", 3)
                 .attr("opacity", .9);
  console.log([typeD, typeA]);
}

function addPoint() {
  graph.nodes.push({"donor": typeD, "acceptor": typeA});
  console.log('nodes', graph.nodes);
  start();
}



/*******************************
 *
 *        OPTIMIZATION
 *
 *******************************/

// Compatibility matrix between different donors and acceptors
var type12 = .5, type13 = .2, type14 = 0;
var type23 = 0, type24 = .7;
var type34 = .6;
var compatibility = [[1, type12, type13, type14],
                     [type12, 1, type23, type24],
                     [type13, type23, 1, type34],
                     [type14, type24, type34, 1]];

// Initial types
var typeD = "type0"; // Donor Type
var typeA = "type1"; // Acceptor Type


function compute() {
  solutionG.selectAll("text").remove("text");
  var vertices = [];
  var edges = { 1 : [], 0.5 : [], 0.2 : [],
                0.7 : [], 0.6 : []};

  var nonzeros = 0;

  for (var i = 0; i < graph.nodes.length; i++) { // Iterate over donors
    vertices.push(i);
    for (var j = 0; j < graph.nodes.length; j++) { // Iterate over acceptors
      if (i !== j) {
        var node1 = graph.nodes[i].donor.charAt(4);
        var node2 = graph.nodes[j].acceptor.charAt(4);
        node1 = parseInt(node1);
        node2 = parseInt(node2);
        var edgeweight = compatibility[node1][node2];
        if (edgeweight !== 0) {
          edges[edgeweight].push([i,j]);
          nonzeros = 1;
        }
      }
    }
  }
  console.log('vertices', vertices);
  console.log('edges', edges);

  if (nonzeros === 0) {
    console.log("No compatible acceptor donor pairs!");
    solutionG.append("text")
             .text("No compatible acceptor donor pairs!")
             .attr("x", centerx)
             .attr("y", centery)
             .attr("font-size", "25px")
             .attr("fill", "white")
             .attr("text-anchor", "middle");
    return;
  }

  d3.json('/kidneyExchange')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'nodes': vertices,
                          'edges': edges}), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);

   if (!error) {
      if ('solution' in data) {

        var solution = data['solution'];
        console.log('solution', solution)

        // Add the edges of the cycles to graph.links
        graph.links = [];
        for (var i = 0; i < solution.length; i++) {
          cycle = solution[i];
          console.log(cycle);
          for (var j = 0; j < cycle.length - 1; j++) {
            graph.links.push({source: cycle[j], target: cycle[j+1],
                       value: 5});
            //console.log(verticesType[cycle[j]]);
          }
          graph.links.push({source: cycle[cycle.length-1], target: cycle[0],
                     value: 5});
          //console.log(verticesType[cycle[cycle.length-1]]);
        }
        console.log('links', graph.links);
        start();
      }
   }
}

</script>
