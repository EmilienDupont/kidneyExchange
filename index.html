<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="http://examples.gurobi.com/base.css">
<style>
a:hover.screenshot {
  opacity: .7;
}

.tabinput {
 width: 40px;
}

rect.add:hover {
  opacity: .5;
}

table, th, td {
    border: 1px solid black;
    padding: 5px;
}

.noselect {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
}

.node {
  stroke-width: 2px;
  stroke: black;
}

.link {
  stroke-width: 5px;
  fill: none;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="example_container">
    <div class="example_section" id="intro">
      <h1>Kidney Exchange</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <p>
      In this example we'll solve the Kidney Exchange Problem: how to
      exchange kidneys between donors and patients in need of a
      transplant.
    </p>

    <p>
      We'll construct a mathematical model of the problem,
      implement this model in Gurobi's Python interface, and compute and
      visualize an optimal solution.
    </p>

    <h3>
      Click the screenshot to skip directly to the Live Demo!
    </h3>
    <p>
      <a href="#demo" class="screenshot">
        <img src="screenshot.png" alt="Live Demo" style="width: 100%; vertical-align: middle;">
      </a>
    </p>

    <div class="example_section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      <p>
        Imagine a person in need of a kidney transplant who has a willing
        donor (e.g. a family member). The donor's kidney is, however,
        incompatible with the patient (because of differing blood types for
        example) and so the transplant cannot be made.
      </p>

      <p>
        Now, suppose there are two patient-donor pairs. Donor 1 and patient
        1 have incompatible kidneys, but donor 2's kidney is compatible with
        patient 1 and donor 1's kidney is compatible with patient 2's. A
        <a href="http://www.cs.cmu.edu/~sandholm/kidneyExchange.EC07.withGrantInfo.pdf">kidney exchange</a>
        can then take place: patient 1 receives kidney 2, and patient 2
        receives kidney 1.
      </p>

      <p>
        Now imagine this problem on a national scale. There are currently
        <a href="http://www.unos.org/">70,000 patients</a> waiting on kidneys
        in the US. Using kidney exchange, the number of deaths related to
        kidney disease could be significantly reduced.
      </p>

      <p>
        Furthermore, kidney exchanges need not be between two patient-donor
        pairs. We could, for example, transplant kidney 1 on patient 2, kidney
        2 on patient 3 and kidney 3 on patient 1. Longer cycles with even more
        patients could be possible, although this is usually not the case in
        practice, for various reasons. For example, if an exchange fails, more
        people would be affected for longer cycles. In addition, all transplants
        must be done simultaneously (otherwise donors could back out after their
        partner has received a kidney), so longer cycles would require more
        medical staff to be at the hospital at the same time. Therefore, in
        practice, the number of donor/recipient pairs in a cycle should be at
        most 3.
      </p>

      <p>
        In summary, we are required to find the set of cycles, of length at
        most 3, which maximizes the number of patients receiving an appropriate
        kidney.
      </p>

    </div>
    <div class="example_section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>
        Kidney exchange is an example of the more general
        <a href="https://en.wikipedia.org/wiki/Barter">Barter Exchange</a> Market
        problem. In this problem, agents seek to swap their items, creating cycles
        of agents where each agent receives the item from the previous agent in
        the cycle. The goal is then to find the cycles which maximize the
        utilities of each agent. In contrast to usual exchanges, items are swapped
        directly without the use of money.
      </p>

      <p>
        There are <a href="http://www.cs.cmu.edu/~sandholm/kidneyExchange.EC07.withGrantInfo.pdf">
        several ways</a> to formulate this problem as an integer program. We will
        use a <em>cycle cover</em> formulation.
      </p>

      <p>
        Let $G$ be a graph where the set of vertices $V$ corresponds to
        donor/recipient pairs and the set of directed weighted edges $E$ represent
        compatibility factors between donors and recipients. If, for example,
        patient 1 and kidney 2 are perfectly compatible (same blood type etc...)
        we give the edge (1,2) weight 1. If they are less compatible and the risk
        of failure of a transplant is higher, then we give the edge a lower weight.
      </p>

      <p>
        Let $C$ be the set of cycles in the graph of length at most 3. Let $w_c$
        denote the weight of the cycle, which is the sum of the edge weights in
        the cycle. Our goal is to find a cycle cover of the graph with maximum
        weight. Therefore we define a binary variable $c$ for each cycle such
        that
        \[
        c = \left\{\begin{array}{ll}
               1 & \text{if cycle is in the cover}\\
               0 & \mathrm{otherwise}
              \end{array}\right.
        \]
      </p>

      <p>
        The objective we seek to maximize is the total weight of the cover, i.e.
        \[
        \text{cycle cover weight} = \sum_{c \in C} w_c c
        \]
      </p>

      <p>
        Now since a recipient only needs to receive one kidney and a donor can
        at most give one kidney, each vertex of the graph can be in at most one
        cycle. To impose this constraint, we first find all the cycles in which
        a given vertex $v$ is included. The sum of the binary variables
        corresponding to these cycles must then at most be one. So we have
        the set of constraints (one for each vertex $v$)
        \[
        \sum_{c : v \in c} c \leq 1 \quad \forall v \in V
        \]
      </p>

      <p>
        So finally our optimization model becomes
        \[
        \begin{array}{ll}
        \text{maximize} & \sum_{c \in C} w_c c \\
        \text{subject to} & \sum_{c : v \in c} c \leq 1 \quad \forall v \in V \\
                          & c \in \{ 0, 1 \} \quad \forall c \in C
        \end{array}
        \]
        in the variables $c$.
      </p>

    </div>
    <div class="example_section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <examplecode>
from gurobipy import *

vertices  = range(5)
edges = { (0,1) : 1, (1,0) : 1, (0,2) : 1, (2,0) : 1,
          (0,4) : 1, (4,0) : 1, (1,4) : 1, (4,1) : 1,
          (1,3) : 1, (3,1) : 1, (2,3) : 1, (3,2) : 1,
          (3,4) : 1, (4,3) : 1 }

def twoCycle(vertices, edges):
    '''
    Returns a dictionary of 2 cycles. Keys: (u,v), Value: weight of cycle
    Note that u < v to not double count cycles.
    '''
    twoCycles = {}
    for edge in edges:
        u = edge[0]
        v = edge[1]
        if (u < v and (v,u) in edges):
            twoCycles[(u,v)] = edges[(u,v)] + edges[(v,u)]
    return twoCycles

def threeCycle(vertices, edges):
    '''
    Returns a dictionary of 3 cycles. Keys: (u,w,v), Value: weight of cycle
    Note that w is always the lowest numbered vertex to not double
    (or triple) count cycles.
    '''
    threeCycles = {}
    for edge in edges:
        u = edge[0]
        v = edge[1]
        for w in vertices:
            if (w >= u or w >= v ):
                break
            if ( (u,w) in edges and (w,v) in edges ):
                threeCycles[(u,w,v)] = edges[(u,v)] + edges[(u,w)] + edges[(w,v)]
    return threeCycles

twoCycles = twoCycle(vertices,edges)
threeCycles = threeCycle(vertices,edges)

m = Model()

c = {}

for cycle in twoCycles:
    c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

for cycle in threeCycles:
    c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

m.update()

for v in vertices:
  constraint = []
  for cycle in c:
      if (v in cycle):
          constraint.append(c[cycle])
  if constraint:
      m.addConstr( quicksum( constraint[i] for i in range(len(constraint)) ) <= 1 , name="v%d" % v)

m.setObjective( quicksum( c[cycle] * twoCycles[cycle] for cycle in twoCycles ) +
                quicksum( c[cycle] * threeCycles[cycle] for cycle in threeCycles ),
                GRB.MAXIMIZE )

m.optimize()
      </examplecode>
    </div>
    <div class="example_section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      <p>
        Below is a visualization of our Kidney Exchange example.
      </p>

      <p>
        Each patient type is represented by a color. There are different
        compatibility factors between different types as shown in the table:

        <table>
        <thead>
        <tr>
        <td></td>
        <td>
        <svg width="40" height="25" style="background-color:#1f77b4;"></svg>
        </td>
        <td>
        <svg width="40" height="25" style="background-color:#ff7f0e;"></svg>
        </td>
        <td>
        <svg width="40" height="25" style="background-color:#2ca02c;"></svg>
        </td>
        <td>
        <svg width="40" height="25" style="background-color:#d62728;"></svg>
        </td>
        </tr>
        <tbody>
        <tr><td>
            <svg width="40" height="25" style="background-color:#1f77b4;"></svg>
            </td>
            <td>100%</td>
            <td>50%</td>
            <td>20%</td>
            <td>0%</td>
        </tr>
        <tr><td>
            <svg width="40" height="25" style="background-color:#ff7f0e;"></svg>
            </td>
            <td>50%</td>
            <td>100%</td>
            <td>0%</td>
            <td>70%</td>
        </tr>
        <tr><td>
            <svg width="40" height="25" style="background-color:#2ca02c;"></svg>
            </td>
            <td>20%</td>
            <td>0%</td>
            <td>100%</td>
            <td>60%</td>
        </tr>
        <tr><td>
            <svg width="40" height="25" style="background-color:#d62728;"></svg>
            </td>
            <td>0%</td>
            <td>70%</td>
            <td>60%</td>
            <td>100%</td>
        </tr>
        </tbody>
        </table>
      </p>
      <p>
        You can add different types of donor/recipient pairs by clicking
        the matrix in the top left corner.
      </p>

      <p>
        Patient/donor pairs are represented by nodes
        <svg height="20" width="20">
          <defs>
            <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="50%" style="stop-color:#1f77b4;stop-opacity:1" />
              <stop offset="50%" style="stop-color:#ff7f0e;stop-opacity:1" />
            </linearGradient>
          </defs>
          <circle cx="10" cy="10" r="8" stroke="black" stroke-width="2" fill="url(#grad1)" />
        </svg>

         where the <em>left</em> side of the circle represents the type of the <em>donor</em>
         and the <em>right</em> side represents the type of the <em>recipient</em>.
      </p>

      <p>
        To find the optimal kidney exchange using Gurobi, click "Compute".
        The colors of the edges represent the type of kidney donated.
      </p>

      <p>
        You can also drag the nodes around to make the visualization clearer.
      </p>

      <table style="width: 800px">
        <thead>
          <tr>
            <td></td>
            <td>
              <svg width="40" height="25" style="background-color:#1f77b4;">
                <text x="10" y="20" style="fill: white">R</text>
              </svg>
            </td>
            <td>
              <svg width="40" height="25" style="background-color:#ff7f0e;">
                <text x="10" y="20" style="fill: white">R</text>
              </svg>
            </td>
        <td>
          <svg width="40" height="25" style="background-color:#2ca02c;">
            <text x="10" y="20" style="fill: white">R</text>
          </svg>
        </td>
        <td>
          <svg width="40" height="25" style="background-color:#d62728;">
            <text x="10" y="20" style="fill: white">R</text>
          </svg>
        </td>
        </tr>
          <tbody>
            <tr>
              <td>
                <svg width="40" height="25" style="background-color:#1f77b4;">
                  <text x="10" y="20" style="fill: white">D</text>
                </svg>
              </td>
              <td></td>
              <td><input type="number" value="0" id="i12" class="tabinput"></td>
              <td><input type="number" value="1" id="i13" class="tabinput"></td>
              <td><input type="number" value="1" id="i14" class="tabinput"></td>
            </tr>
            <tr>
              <td>
                <svg width="40" height="25" style="background-color:#ff7f0e;">
                  <text x="10" y="20" style="fill: white">D</text>
                </svg>
              </td>
              <td><input type="number" value="2" id="i21" class="tabinput"></td>
              <td></td>
              <td><input type="number" value="1" id="i23" class="tabinput"></td>
              <td><input type="number" value="1" id="i24" class="tabinput"></td>
            </tr>
            <tr>
              <td>
                <svg width="40" height="25" style="background-color:#2ca02c;">
                  <text x="10" y="20" style="fill: white">D</text>
                </svg>
              </td>
              <td><input type="number" value="1" id="i31" class="tabinput"></td>
              <td><input type="number" value="1" id="i32" class="tabinput"></td>
              <td></td>
              <td><input type="number" value="2" id="i34" class="tabinput"></td>
        </tr>
        <tr>
          <td>
            <svg width="40" height="25" style="background-color:#d62728;">
              <text x="10" y="20" style="fill: white">D</text>
            </svg>
          </td>
          <td><input type="number" value="1" id="i41" class="tabinput"></td>
          <td><input type="number" value="1" id="i42" class="tabinput"></td>
          <td><input type="number" value="0" id="i43" class="tabinput"></td>
          <td></td>
        </tr>
          </tbody>
      </table>

      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute</button>
      <p>
        <button class="pure-button" onclick="toggle_div()">Gurobi Log</button>
      </p>


      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
        function toggle_div() {
          var logfile = d3.select('#logfile');
          if (logfile.style("display") === "none") {
            logfile.style("display", "block");
          } else {
            logfile.style("display", "none");
          }
        }
      </script>

      <examplecode id=logfile>
      </examplecode>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/1.2.7/spin.min.js"></script>
<script>

// Hide Log File initially
d3.select('#logfile').style("display", "none");

// Needed for loading screen
var spinner;

//Width, height button width, menu size
var width = 800;
var height = 650;
var colors = d3.scale.category10();

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

var colorGradients = [];

// Each row is a donor, each column is a recipient
for (var i = 0; i < 4; i++) {
  var row = [];
  for (var j = 0; j < 4; j++) {
    if (i !== j) {
      var id = "grad" + String(i) + String(j);
      row.push(svg.append("defs").append("linearGradient").attr("id", id)
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%"));
      row[row.length-1].append("stop").attr("offset", "50%").style("stop-color", colors(i));
      row[row.length-1].append("stop").attr("offset", "50%").style("stop-color", colors(j));
    }
  }
  colorGradients.push(row);
}

var nodeNumber = 0;

/*******************************
 *
 *      CREATING G OBJECTS
 *
 *******************************/
// G object for points
var backgroundG = svg.append("g");

// G objects for force layout
var linksG = svg.append("g");
var nodesG = svg.append("g");

// G object for spinner
var spinnerG = svg.append("g");

/*******************************
 *
 *     CREATE FORCE LAYOUT
 *
 *******************************/

// Set up force layout
var force = d3.layout.force()
    .charge(-200)
    .linkDistance(80)
    .size([width, height]);

var nodes = force.nodes();
var links = force.links();


var matrix = (function () {
   /* row = matrix[i] */
   /* row[j] = element i j */
   var mat = [];
   for (var i = 0; i < 4; i++) {
      var row = [];
      for (var j = 0; j < 4; j++) {
        if (i !== j) {
           var myid = "#i" + (i+1) + (j+1);
           var sel = d3.select(myid);
           console.log(myid, sel);
           console.log(myid, sel.attr("value"));
           var elem = +sel.attr("value");
           row.push(elem);
           for (var k = 0; k < elem; k++) {
               addNode(i, j);
           }
        } else {
           row.push(0);
        }
      }
      mat.push(row);
   }
  return mat;
}());

d3.selectAll(".tabinput")
    .attr("min", 0)
    .attr("max", 99)
    .on("input", function () {
      console.log(this.id, this.value);
      if (+this.value > 99) {
        this.value = 99;
      }
      if (+this.value !== +this.value) {
        this.value = 0;
      }
      var idtxt = this.id;
      var i = +idtxt[1]-1;
      var j = +idtxt[2]-1;
      var oldval = matrix[i][j];
      matrix[i][j] = +this.value;
      var delta;
      if (oldval < matrix[i][j]) {
         for (delta = oldval; delta < matrix[i][j]; delta++) {
             addNode(i, j);
         }
      } else  if (oldval > matrix[i][j]) {
         for (delta = oldval; delta > matrix[i][j]; delta--) {
            removeNode(i, j);
         }
      }
    })



// Functions needed for force layout interaction
function addNode(donor, acceptor) {
  console.log('nodeNumber',nodeNumber);
  nodeNumber++;
  nodes.push({"id": nodeNumber,
              "donor": donor,
              "acceptor": acceptor });
  removeAllLinks();
}

function removeNode(donor, acceptor) {
  var idx = -1;
  for (var i = 0; i < nodes.length; i++) {
    console.log('donor', nodes[i].donor, donor);
    if (nodes[i].donor === donor && nodes[i].acceptor === acceptor) {
      console.log('node found', i);
      idx = i;
      break;
    }
  }
  if (idx < 0) {
    console.log('no node');
    return;
  } else {
    nodes.splice(idx, 1);
    start();
  }
  removeAllLinks();
}

function addLink(source, target, value) {
  // Better to initialize source and target to objects explicitly
  // If we add links with source and target as integer indexs
  // before to call to force.start(), these are replaced by objects
  // automatically by d3. But if we add links when the simulation
  // is already running, source and target need to be objects

  sourceNode = nodes[source];
  targetNode = nodes[target];

  links.push({"source":sourceNode,"target":targetNode,"value":value});
  start();
}

function removeAllLinks() {
  links.splice(0,links.length);
  start();
}

function start() {

  var link = linksG.selectAll(".link")
                .data(links);

  link.enter().append("path")
      .attr("d", function(d) {
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            return "M" +
                d.source.x + "," +
                d.source.y + "A" +
                dr + "," + dr + " 0 0,1 " +
                d.target.x + "," +
                d.target.y;
      })
      .attr("class", "link")
      .style("stroke", function(d) { var src = d.source;
                                     var donortype = src.donor;
                                     return colors(donortype);} );

  link.exit().remove();

  var groups = nodesG.selectAll(".compositenode")
                     .data(nodes, function(d) { return d.id;})

  var groupEnter = groups.enter().append("g")
            .attr("class", "compositenode")
            .call(force.drag);

  groupEnter.append("circle")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", 20)
        .attr("stroke", "black")
        .attr("stroke-width", 3)
        .style("fill", function(d) { return colorgradient(d.donor, d.acceptor);})

  groupEnter.append("text")
        .attr("x", -14)
        .attr("y", 7)
        .text("D")
        .style("fill", "black");
   //     .style("fill", function(d) { return colors(d.donor); });

  groupEnter.append("text")
        .attr("x", 2)
        .attr("y", 7)
        .text("R")
        .style("fill", "black");
 //       .style("fill", function(d) { return colors(d.acceptor); });

  groups.exit().remove();

  force.on("tick", function() {
        link.attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" +
            d.source.x + "," +
            d.source.y + "A" +
            dr + "," + dr + " 0 0,1 " +
            d.target.x + "," +
            d.target.y;
        });

        groups.attr("transform", function(d, i) {
            var x = d.x;
            var y = d.y;
            return "translate(" + [x,y] + ")";
        });

  })

  force.start();
}


function colorgradient(i, j) {
  return "url(#grad" + i + j + ")"; // E.g. if "type0" return colors(0)
}


/*******************************
 *
 *CREATE BACKGROUND AND BUTTONS
 *
 *******************************/

backgroundG.append("rect")
           .attr("x",0)
           .attr("y",0)
           .attr("width", width)
           .attr("height", height)
           .attr("fill", "white")
           .attr("stroke", "black");

/*******************************
 *
 *        COMPATIBILITY DATA
 *
 *******************************/

// Compatibility matrix between different donors and acceptors
var type12 = .5, type13 = .2, type14 = 0;
var type23 = 0, type24 = .7;
var type34 = .6;
var compatibility = [[1, type12, type13, type14],
                     [type12, 1, type23, type24],
                     [type13, type23, 1, type34],
                     [type14, type24, type34, 1]];


/*******************************
 *
 *        OPTIMIZATION
 *
 *******************************/

function compute() {
  if (force.nodes().length < 2) {
    alert("Not enough donor/recipient pairs. Add more nodes!");
    return;
  }
  // Show loading screen
  spinnerG.append("rect")
          .attr("x", 0).attr("y", 0)
          .attr("width", width).attr("height", height)
          .attr("fill", "white")
          .attr("opacity", .5);
  spinnerG.append("text")
          .attr("x", width/2)
          .attr("y", .4*height)
          .attr("font-size", 25)
          .attr("font-family", "Helvetica Neue")
          .attr("font-weight", 400)
          .attr("text-anchor", "middle")
          .text("Computing...");
  var target = document.getElementById('demoarea');
  spinner = new Spinner({left: '375%'}).spin(target);

  var vertices = [];
  var edges = { 1 : [], 0.5 : [], 0.2 : [],
                0.7 : [], 0.6 : []};

  var nonzeros = 0;

  var numNodes = force.nodes().length;
  var nodes = force.nodes();

  for (var i = 0; i < numNodes; i++) { // Iterate over donors
    vertices.push(i);
    for (var j = 0; j < numNodes; j++) { // Iterate over acceptors
      if (i !== j) {
        var node1 = nodes[i].donor;
        var node2 = nodes[j].acceptor;
        node1 = parseInt(node1);
        node2 = parseInt(node2);
        var edgeweight = compatibility[node1][node2];
        if (edgeweight !== 0) {
          edges[edgeweight].push([i,j]);
          nonzeros = 1;
        }
      }
    }
  }
  console.log('vertices', vertices);
  console.log('edges', edges);

  d3.json('kidneyexchange.py')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'nodes': vertices,
                          'edges': edges}), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);

   // Remove loading screen
   spinnerG.selectAll("rect").remove("rect");
   spinnerG.selectAll("text").remove("text");
   spinner.stop();

   if (!error) {
      if ('solution' in data) {

        var solutionTemp = data['solution'];
        console.log('solution', solutionTemp)
        if (solutionTemp[0] === "error") {
          alert("10 second solve time limit exceeded. Reduce the number of patients.");
          return;
        }
        var solution = solutionTemp[0];
        var logMsg = solutionTemp[1]; // Log message to display

        d3.select('#logfile').html(logMsg);

        removeAllLinks();

        if (solution.length < 1) {
          alert("No compatible donor recipient pairs! Add more nodes.");
          return;
        }
        // Add the edges of the cycles to graph.links
        for (var i = 0; i < solution.length; i++) {
          cycle = solution[i];
          console.log(cycle);
          for (var j = 0; j < cycle.length - 1; j++) {
            addLink(cycle[j], cycle[j+1], 5);
          }
          addLink(cycle[cycle.length-1],cycle[0], 5);
        }
      }
   }
}

</script>
