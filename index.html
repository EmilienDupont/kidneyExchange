<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>

@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}

.type0 {
  fill: red;
}

.type1 {
  fill: blue;
}

.type2 {
  fill: green;
}

.type3 {
  fill: yellow;
}

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Kidney Exchange</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <p> Imagine a person in need of a kidney transplant who has a willing donor (e.g.
    a family member). The donor's kidney is, however, incompatible with the patient
    (because of differing blood types for example) and so the transplant cannot be made.
    Now, suppose there are two patient-donor pairs. Donor 1 and patient 1 have incompatible
    kidneys, but donor 2's kidney is compatible with patient 1 and donor 1's kidney is
    compatible with patient 2's. A kidney exchange can then take place: patient 1 receives
    kidney 2, and patient 2 receives kidney 1.</p>

    <p> Now imagine this problem on a national scale. There are currently 70,000 patients
    waiting on kidneys in the US. Using kidney exchange, the number of deaths related to
    kidney disease could be significantly reduced. </p>

    <p>
      In this example we'll solve the kidney exchange problem. We'll construct a mathematical
      model of the problem, implement this model in Gurobi's Python interface, and compute
      and visualize an optimal solution.
    </p>
    <p> Reference the http://www.cs.cmu.edu/~sandholm/kidneyExchange.EC07.withGrantInfo.pdf paper</p>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here
      <p> Mention why cycles need to be short</p>
      <p>
        Kidney exchange is an example of the more general Barter Exchange Market problem.
        In this problem, agents seek to swap their items, creating cycles of agents where
        each agent receives the item from the previous agent in the cycle. The goal is then
        to find the cycles which maximize the utilities of each agent.
      </p>
    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>

      <p> Let $G$ be a graph where the set of vertices $V$ corresponds to acceptor/donor pairs
      and the set of directed weighted edges $E$ represent a compatibility factor between a donor and an acceptor. </p>

      <p> Let $C$ be the set of cycles in the graph of length at most 3. Let $w_c$ denote the weight of
      the cycle, which is the sum of the edge weights in the cycle. Our goal is to find a cycle cover
      of the graph with maximum weight. Therefore we define a binary variable $c$ for each cycle
      such that
      \[
      c = \left\{\begin{array}{ll}
             1 & \text{if cycle is in the cover}\\
             0 & \mathrm{otherwise}
            \end{array}\right.
      \]
      </p>
      <p> The objective we seek to maximize is the total weight of the cover, i.e.
      \[
      \text{cycle cover weight} = \sum_{c \in C} w_c c
      \]</p>
      <p> Now since an acceptor only needs to receive one kidney and a donor can at most give one kidney,
    each vertex of the vertex the graph can be in at most one cycle. We therefore find all the cycles in which
    a given vertex $v$ is included. To impose the constraint, the sum of these binary variables can at most be one.
    So we have the set of constraints (one for each vertex $v$)
    \[
    \sum_{c : v \in c} c \leq 1 \quad \forall v \in V
    \]
      </p>
      <p> So finally we have
       \[
      \begin{array}{ll}
      \text{maximize} & \sum_{c \in C} w_c c \\
      \text{subject to} & \sum_{c : v \in c} c \leq 1 \quad \forall v \in V \\
                        & c \in \{ 0, 1 \} \quad \forall c \in C
      \end{array}
      \]
      </p>
    </div>
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
      from gurobipy import *

      vertices  = range(5)
      edges = { (0,1) : 1, (1,0) : 1, (0,2) : 1, (2,0) : 1,
                (0,4) : 1, (4,0) : 1, (1,4) : 1, (4,1) : 1,
                (1,3) : 1, (3,1) : 1, (2,3) : 1, (3,2) : 1,
                (3,4) : 1, (4,3) : 1 }

      def twoCycle(vertices, edges):
          '''
          Returns a dictionary of 2 cycles. Keys: (u,v), Value: weight of cycle
          Note that u < v to not double count cycles.
          '''
          twoCycles = {}
          for edge in edges:
              u = edge[0]
              v = edge[1]
              if (u < v and (v,u) in edges):
                  twoCycles[(u,v)] = edges[(u,v)] + edges[(v,u)]
          return twoCycles

      def threeCycle(vertices, edges):
          '''
          Returns a dictionary of 3 cycles. Keys: (u,w,v), Value: weight of cycle
          Note that w is always the lowest numbered vertex to not double
          (or triple) count cycles.
          '''
          threeCycles = {}
          for edge in edges:
              u = edge[0]
              v = edge[1]
              for w in vertices:
                  if (w >= u or w >= v ):
                      break
                  if ( (u,w) in edges and (w,v) in edges ):
                      threeCycles[(u,w,v)] = edges[(u,v)] + edges[(u,w)] + edges[(w,v)]
          return threeCycles

      twoCycles = twoCycle(vertices,edges)
      threeCycles = threeCycle(vertices,edges)

      m = Model()

      c = {}

      for cycle in twoCycles:
          c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

      for cycle in threeCycles:
          c[cycle] = m.addVar(vtype=GRB.BINARY, name="c_%s" % str(cycle))

      m.update()

      for v in vertices:
        constraint = []
        for cycle in c:
            if (v in cycle):
                constraint.append(c[cycle])
        if constraint:
            m.addConstr( quicksum( constraint[i] for i in range(len(constraint)) ) <= 1 , name="v%d" % v)

      m.setObjective( quicksum( c[cycle] * twoCycles[cycle] for cycle in twoCycles ) +
                      quicksum( c[cycle] * threeCycles[cycle] for cycle in threeCycles ),
                      GRB.MAXIMIZE )

      m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p> Click on the buttons at the top to change the type of acceptor/donor pairs. Click
      on the circles to add/change pairs. Click compute to compute the optimal kidney exchange. </p>
      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute</button>
    </div>

    <div style="min-height:100px"></div>
<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

//Width, height and button width
var width = 800;
var height = 650;
var bw = width/10;
var menu = 80;

// Compatibility matrix between different donors and acceptors
var type12 = .5, type13 = .2, type14 = 0;
var type23 = 0, type24 = .7;
var type34 = .6;
var compatibility = [[1, type12, type13, type14],
                     [type12, 1, type23, type24],
                     [type13, type23, 1, type34],
                     [type14, type24, type34, 1]];

// Initial types
var typea = "type0";
var typeb = "type1";

// Graphics
var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

var backgroundG = svg.append("g");
backgroundG.append("rect")
           .attr("x", 0)
           .attr("y", menu)
           .attr("width", width)
           .attr("height", height - menu)
           .attr("fill", "rgb(240,240,240");


// Different color gradients for the half circles
var grad00 = svg.append("defs").append("linearGradient").attr("id", "grad00")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad00.append("stop").attr("offset", "50%").style("stop-color", "red");
grad00.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad01 = svg.append("defs").append("linearGradient").attr("id", "grad01")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad01.append("stop").attr("offset", "50%").style("stop-color", "red");
grad01.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad02 = svg.append("defs").append("linearGradient").attr("id", "grad02")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad02.append("stop").attr("offset", "50%").style("stop-color", "red");
grad02.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad03 = svg.append("defs").append("linearGradient").attr("id", "grad03")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad03.append("stop").attr("offset", "50%").style("stop-color", "red");
grad03.append("stop").attr("offset", "50%").style("stop-color", "yellow");
var grad10 = svg.append("defs").append("linearGradient").attr("id", "grad10")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad10.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad10.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad11 = svg.append("defs").append("linearGradient").attr("id", "grad11")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad11.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad11.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad12 = svg.append("defs").append("linearGradient").attr("id", "grad12")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad12.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad12.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad13 = svg.append("defs").append("linearGradient").attr("id", "grad13")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad13.append("stop").attr("offset", "50%").style("stop-color", "blue");
grad13.append("stop").attr("offset", "50%").style("stop-color", "yellow");
var grad20 = svg.append("defs").append("linearGradient").attr("id", "grad20")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad20.append("stop").attr("offset", "50%").style("stop-color", "green");
grad20.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad21 = svg.append("defs").append("linearGradient").attr("id", "grad21")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad21.append("stop").attr("offset", "50%").style("stop-color", "green");
grad21.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad22 = svg.append("defs").append("linearGradient").attr("id", "grad22")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad22.append("stop").attr("offset", "50%").style("stop-color", "green");
grad22.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad23 = svg.append("defs").append("linearGradient").attr("id", "grad23")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad23.append("stop").attr("offset", "50%").style("stop-color", "green");
grad23.append("stop").attr("offset", "50%").style("stop-color", "yellow");
var grad30 = svg.append("defs").append("linearGradient").attr("id", "grad30")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad30.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad30.append("stop").attr("offset", "50%").style("stop-color", "red");
var grad31 = svg.append("defs").append("linearGradient").attr("id", "grad31")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad31.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad31.append("stop").attr("offset", "50%").style("stop-color", "blue");
var grad32 = svg.append("defs").append("linearGradient").attr("id", "grad32")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad32.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad32.append("stop").attr("offset", "50%").style("stop-color", "green");
var grad33 = svg.append("defs").append("linearGradient").attr("id", "grad33")
              .attr("x1", "0%").attr("x2", "100%").attr("y1", "0%").attr("y2", "0%");
grad33.append("stop").attr("offset", "50%").style("stop-color", "yellow");
grad33.append("stop").attr("offset", "50%").style("stop-color", "yellow");


var vertices = [];
var verticesType = [];
// Initial vertex types
//var verticesType = [["type2","type0"], ["type1","type3"], ["type2","type1"],
//                    ["type0","type3"], ["type3","type1"], ["type1","type0"]];

var buttondata1 = [bw, 2*bw, 3*bw, 4*bw];
var buttondata2 = [6*bw, 7*bw, 8*bw, 9*bw];

// G object for points
var pointsG = svg.append("g");

// G object for solution
var solutionG = svg.append("g");

// G objects for buttons
var buttonsG1 = svg.append("g");
var buttonsG2 = svg.append("g");
var buttonsG3 = svg.append("g");

// Create graphics related to buttons
buttonsG1.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", menu)
        .attr("fill", "black")
        .attr("opacity", .5)
        .attr("stroke", "black");

buttonsG1.append("text")
        .attr("x", width/4)
        .attr("y", 25)
        .text("DONOR");

buttonsG1.append("text")
        .attr("x", 3*width/4)
        .attr("y", 25)
        .text("ACCEPTOR");

buttonsG1.selectAll("text")
       .attr("font-size", "25px")
       .attr("fill", "white")
       .attr("text-anchor", "middle");

var buttons1 = buttonsG1.selectAll("circle")
          .data(buttondata1)
          .enter()
          .append("circle")
          .attr("cx", function(d) { return d; })
          .attr("cy", 55)
          .attr("r", 15)
          .attr("class", function(d,i) { return "type" + i % 4 ; })
          .attr("stroke-width", function(d,i) { if (i === 0) { return 3; } else { return 1; } })
          .attr("opacity", function(d,i) { if (i === 0) { return 0.9; } else { return .3; } })
          .attr("stroke", "black")
          .on("mousedown", buttonpress1);

var buttons2 = buttonsG2.selectAll("circle")
          .data(buttondata2)
          .enter()
          .append("circle")
          .attr("cx", function(d) { return d; })
          .attr("cy", 55)
          .attr("r", 15)
          .attr("class", function(d,i) { return "type" + i % 4 ; })
          .attr("stroke-width", function(d,i) { if (i === 1) { return 3; } else { return 1; } })
          .attr("opacity", function(d,i) { if (i === 1) { return 0.9; } else { return .3; } })
          .attr("stroke", "black")
          .on("mousedown", buttonpress2);

buttonsG3.append("rect")
         .attr("x", width/2 - 50)
         .attr("y", 25)
         .attr("height", 50)
         .attr("width", 100)
         .attr("stroke-width", 3)
         .attr("stroke", "black")
         .attr("fill", "rgb(210,210,210)")
         .on("mousedown", addPoint);

buttonsG3.append("text")
        .text("ADD")
        .attr("x", width/2)
        .attr("y", 60)
        .attr("font-size", "25px")
        .attr("fill", "white")
        .attr("text-anchor", "middle");

function buttonpress1() {
  typea = d3.select(this).attr("class");
  buttons1.attr("stroke-width", 1)
          .attr("opacity", .3);
  d3.select(this).attr("stroke-width", 3)
                 .attr("opacity", .9);
  console.log([typea, typeb]);
}

function buttonpress2() {
  typeb = d3.select(this).attr("class");
  buttons2.attr("stroke-width", 1)
          .attr("opacity", .3);
  d3.select(this).attr("stroke-width", 3)
                 .attr("opacity", .9);
  console.log([typea, typeb]);
}

function indexArray (array, point) {
  var p0 = point[0];
  var p1 = point[1];
  var index = -1;
  for (i = 0; i < array.length; i++) {
    pointprime = array[i];
    if (p0 === pointprime[0] && p1 === pointprime[1]) {
      index = i;
      break;
    }
  }
  return index;
}

function colorfill() {
  if (typea === "type0" && typeb === "type0") { return "url(#grad00)"; }
  if (typea === "type0" && typeb === "type1") { return "url(#grad01)"; }
  if (typea === "type0" && typeb === "type2") { return "url(#grad02)"; }
  if (typea === "type0" && typeb === "type3") { return "url(#grad03)"; }
  if (typea === "type1" && typeb === "type0") { return "url(#grad10)"; }
  if (typea === "type1" && typeb === "type1") { return "url(#grad11)"; }
  if (typea === "type1" && typeb === "type2") { return "url(#grad12)"; }
  if (typea === "type1" && typeb === "type3") { return "url(#grad13)"; }
  if (typea === "type2" && typeb === "type0") { return "url(#grad20)"; }
  if (typea === "type2" && typeb === "type1") { return "url(#grad21)"; }
  if (typea === "type2" && typeb === "type2") { return "url(#grad22)"; }
  if (typea === "type2" && typeb === "type3") { return "url(#grad23)"; }
  if (typea === "type3" && typeb === "type0") { return "url(#grad30)"; }
  if (typea === "type3" && typeb === "type1") { return "url(#grad31)"; }
  if (typea === "type3" && typeb === "type2") { return "url(#grad32)"; }
  if (typea === "type3" && typeb === "type3") { return "url(#grad33)"; }
  return "black"; // Return default color if there is an error
}

function addPoint() {
  var point = d3.mouse(this);

  console.log('point', point)
  var check = indexArray(vertices, point);
  if (check > -1) {
    console.log('point already exists!');
    verticesType[check] = [typea,typeb];
    return;
  } else {
    vertices.push(point);
    verticesType.push([typea, typeb]);
  }

  console.log('verticesType', verticesType);
  console.log('vertices', vertices)
}

function compute() {
  solutionG.selectAll("text").remove("text");
  var nodes = [];
  var edges = { 1 : [], 0.5 : [], 0.2 : [],
                0.7 : [], 0.6 : []};

  var nonzeros = 0;

  for (var i = 0; i < verticesType.length; i++) { // Iterate over donors
    nodes.push(i);
    for (var j = 0; j < verticesType.length; j++) { // Iterate over acceptors
      if (i !== j) {
        var node1 = verticesType[i][0].charAt(4);
        var node2 = verticesType[j][1].charAt(4);
        node1 = parseInt(node1);
        node2 = parseInt(node2);
        var edgeweight = compatibility[node1][node2];
        if (edgeweight !== 0) {
          edges[edgeweight].push([i,j]);
          nonzeros = 1;
        }
      }
    }
  }
  console.log('nodes', nodes);
  console.log('edges', edges);

  if (nonzeros === 0) {
    console.log("No compatible acceptor donor pairs!");
    solutionG.append("text")
             .text("No compatible acceptor donor pairs!")
             .attr("x", centerx)
             .attr("y", centery)
             .attr("font-size", "25px")
             .attr("fill", "white")
             .attr("text-anchor", "middle");
    return;
  }

  d3.json('/kidneyExchange')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'nodes': nodes,
                          'edges': edges}), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('solution' in data) {
          var solution = data['solution'];
          console.log('solution', solution)
          links = []
          for (var i = 0; i < solution.length; i++) {
            cycle = solution[i];
            console.log(cycle);
            var arrowType = "arrow" + String(i);
            for (var j = 0; j < cycle.length - 1; j++) {
              links.push({source: cycle[j], target: cycle[j+1],
                         type: arrowType});
              console.log(verticesType[cycle[j]]);
            }
            links.push({source: cycle[cycle.length-1], target: cycle[0],
                       type: arrowType});
            console.log(verticesType[cycle[cycle.length-1]]);
          }
          console.log('links', links);
          console.log('verticesType', verticesType)
          solutionG.selectAll("path").remove("path");

          // Draw the cycles
          var cycles = solutionG.selectAll("path")
                    .data(links)
                    .enter()
                    .append("path")
                    .attr("class", function(d) { return "link " + d.type;})
                    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; }) // Note that # refers to the id of the object
                    .attr("d", function(d) { return linkArc(d); })
                    .attr("stroke-opacity", .7)
                    .attr("stroke-width", 3);
      }
   }
}
</script>
